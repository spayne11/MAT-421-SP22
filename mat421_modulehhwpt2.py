# -*- coding: utf-8 -*-
"""mat421.moduleHhwpt2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-fP2rnl3E8h9Cz0pJy00UqyHMo-Tq7vb

Sydney Payne

Spring 2022 - MAT 421

Module H Homework: CH 22.4, 22.5, and 22.6

CH 22.4: Numerical Error and Instability
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from numpy.linalg import inv
import matplotlib.pyplot as plt

plt.style.use('seaborn-poster')

# %matplotlib inline 

# define step size
h = 0.1
# define numerical grid
t = np.arange(0, 5.1, h)
# oscillation freq. of pendulum
w = 4
s0 = np.array([[1], [0]])

m_e = np.array([[1, h], 
               [-w**2*h, 1]])
m_i = inv(np.array([[1, -h], 
               [w**2*h, 1]]))
m_t = np.dot(inv(np.array([[1, -h/2], 
    [w**2*h/2,1]])), np.array(
      [[1,h/2], [-w**2*h/2, 1]]))

s_e = np.zeros((len(t), 2))
s_i = np.zeros((len(t), 2))
s_t = np.zeros((len(t), 2))

# do integrations
s_e[0, :] = s0.T
s_i[0, :] = s0.T
s_t[0, :] = s0.T

for j in range(0, len(t)-1):
    s_e[j+1, :] = np.dot(m_e,s_e[j, :])
    s_i[j+1, :] = np.dot(m_i,s_i[j, :])
    s_t[j+1, :] = np.dot(m_t,s_t[j, :])
    
plt.figure(figsize = (12, 8))
plt.plot(t,s_e[:,0],'b-')
plt.plot(t,s_i[:,0],'g:')
plt.plot(t,s_t[:,0],'r--')
plt.plot(t, np.cos(w*t), 'k')
plt.ylim([-3, 3])
plt.xlabel('t')
plt.ylabel('$\Theta (t)$')
plt.legend(['Explicit', 'Implicit', \
            'Trapezoidal', 'Exact'])
plt.show()

"""CH 22.6: Python ODE Solvers"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import solve_ivp

plt.style.use('seaborn-poster')

# %matplotlib inline

F1 = lambda t1, s1: np.cos(t1)

t_eval = np.arange(0, np.pi, 0.1)
sol = solve_ivp(F1, [0, np.pi], [0], t_eval=t_eval)

plt.figure(figsize = (12, 4))
plt.subplot(121)
plt.plot(sol.t, sol.y[0])
plt.xlabel('t1')
plt.ylabel('S1(t1)')
plt.subplot(122)
plt.plot(sol.t, sol.y[0] - np.sin(sol.t))
plt.xlabel('t1')
plt.ylabel('S1(t1) - sin(t1)')
plt.tight_layout()
plt.show()

sol = solve_ivp(F1, [0, np.pi], [0], t_eval=t_eval, \
                rtol = 1e-8, atol = 1e-8)

plt.figure(figsize = (12, 4))
plt.subplot(121)
plt.plot(sol.t, sol.y[0])
plt.xlabel('t1')
plt.ylabel('S1(t1)')
plt.subplot(122)
plt.plot(sol.t, sol.y[0] - np.sin(sol.t))
plt.xlabel('t1')
plt.ylabel('S1(t1) - sin(t1)')
plt.tight_layout()
plt.show()

F2 = lambda t2, s2: -s2

t_eval = np.arange(0, 1.01, 0.01)
sol = solve_ivp(F2 , [0, 1], [1], t_eval=t_eval)

plt.figure(figsize = (12, 4))
plt.subplot(121)
plt.plot(sol.t, sol.y[0])
plt.xlabel('t')
plt.ylabel('S2(t2)')
plt.subplot(122)
plt.plot(sol.t, sol.y[0] - np.exp(-sol.t))
plt.xlabel('t2')
plt.ylabel('S2(t2) - exp(-t2)')
plt.tight_layout()
plt.show()

F3 = lambda t3, s3: np.dot(np.array([[0, t3**2], [-t3, 0]]), s3)

t_eval = np.arange(0, 10.01, 0.01)
sol = solve_ivp(F3, [0, 10], [1, 1], t_eval=t_eval)

plt.figure(figsize = (12, 8))
plt.plot(sol.y.T[:, 0], sol.y.T[:, 1])
plt.xlabel('x')
plt.ylabel('y')
plt.show()

"""End of Chapter Questions 

    3.
"""

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

def my_lorenz_solver(t_span, s04, sigma, rho, beta):
  s4=np.array([1,2,3])
  def my_lorenz(t4, S4, sigma, beta, rho):
    x4,y4,z4=S4
    dx4=sigma*(y4-x4)
    dy4=x4*(rho-z4)-y4
    dz4=x4*y4-beta*z4
    dS4=[dx4,dy4,dz4]
    return dS4
  dS4=my_lorenz(0,s4,10,28,8/3)
  from functools import partial
  t04=t_span[0]
  tf4=t_span[1]
  t4=np.linspace(t04,tf4,20001)
  f4=partial(my_lorenz, sigma=sigma, rho=rho, beta=beta)
  sol4=solve_ivp(f4, t_span, s04, t_eval=t4)
  T,X,Y,Z=sol4.t4.y4[0,:], sol4.y4[1,:], sol4.y4[2,:]
  return[T,X,Y,Z]

sigma=10
rho=28
beta=8/3
t04=0
tf4=50
s04=np.array([0,1,1.05])
[T,X,Y,Z]=my_lorenz_solver([t04,tf4],s04,sigma,rho,beta)
fig=plt.figure(figsize=(10,10))
ax=plt.axes(projection="3d")
ax.grid()
ax.plt3D(X,Y,Z)
ax.set_xlabel("x",labelpad=20)
ax.set_ylabel("y",labelpad=20)

"""    4."""

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from functools import partial

def my_msd(t5,S5,m5,c5,k5):
  dS5=np.dot(np.array([[0,1],[-k5/m5,-c5/m5]]),S5)
  return dS5

dS5=my_msd(0,[1,-1],10,1,100)
print(dS5)

m5=1
k5=10
f5=partial(my_msd,m5=m5,c5=0,k5=k5)
t_e=np.arange(0,20,0.1)
sol_1=solve_ivp(f5,[0,20],[1,0],t_eval=t_e)
f5=partial(my_msd,m5=m5,c5=1,k5=k5)
sol_2=solve_ivp(f5,[0,20],[1,0],t_eval=t_e)
f5=partial(my_msd,m5=m5,c5=10,k5=k5)
sol_3=solve_ivp(f5,[0,20],[1,0],t_eval=t_e)

plt.figure(figsize=(10,8))
plt.plot(sol_1.t5,sol_1.y[0])
plt.plot(sol_2.t5,sol_2.y[0])
plt.plot(sol_3.t5,sol_3.y[0])
plt.title("Numerical Solution of MSD \ System with Varying Damping")
plt.xlabel("time")
plt.ylabel("displacement")
plt.legend(["no dampling","c=1",">critically damped"],loc-1)
plt.show()

"""    5."""

clear[t,f,sol,t_eval,dS,s]

import numpy as np
def my_forward_euler(ds,t_span,s0):
  if (len(t_span)<2):
    raise BaseException("Error: span must be of length more than 1!")
  h=(t_span[-1]-t_span[0]/(len(t_span)-1)
  s=np.zeros((len(t_span)+1,1))
  s[0]=s0
  for i in range(0,len(t_span)):
    s[i+1]=s[i]+h*ds(t_span[i],s[i])
  t=t_span
  s=s.transpose()[0]
  return [t,s]

t_span=np.linspace(0,1,10)
s0=1
f=lambda t,s:t*np.exp(-s)
t_eul,s_eul=my_forward_euler(f,t_span,s0)
print(t_eul)
print(s_eul)

"""    6."""

clear[t_span,s0]

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

def myRK4(ds,t_span,s0):
  if (len(t_span)<2):
    raise BaseException("Error: span must be of length more than 1")
  h=(t_span[-1]-t_span[0])/(len(t_span)-1)
  s=np.zeros((len(t_span),1))
  s[0]=s0
  for i in range(0,len(t_span)-1):
    k1=ds(t_span[i],s[i]);
    k2=ds(t_span[i]+0.5*h,s[i]+0.5*h*k1);
    k3=ds(t_span[i]+0.5*h,s[i]+0.5*h*k2);
    k4=ds(t_span[i]+h,s[i]+h*k3);
    s[i+1]=s[i]+h/6*(k1+2*k2+2*k3+k4);
  t=t_span
  s=s.transpose()[0]
  return [t,s]

f=lambda t,s: np.sin(np.exp(s))/(t+1)
t_span=np.linspace(0,2*np.pi,10)
s0=0
plt.figure(figsize=(10,8))
t,s=myRK4(f,t_span,s0)
plt.plot(t,s,"r",label="RK4")
sol=solve_ivp(f,[0,2*np.pi],[s0],t_eval=t)
plt.plot(sol.t,sol.y[0],"b-",label="Python Solver")
plt.xlabel("t")
plt.ylabel("f(t)")
plt.grid()
plt.legend(loc=2)
plt.show()

