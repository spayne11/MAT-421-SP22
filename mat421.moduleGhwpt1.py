# -*- coding: utf-8 -*-
"""mat421.moduleGhwpt1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XVQ-hp9I-Klgc0ISwOYY7N4JeONJb9Vk

Sydney Payne

Spring 2022 - MAT 421

Module G Homework: CH 21

Ch 21.1: Numerical Intergration Problem Statement

Ch 21.2: Riemann Integral
"""

import numpy as np

a1=0
b1=np.pi
n1=11
h1=(b1-a1)/(n1-1)
x1=np.linspace(a1,b1,n1)
f1=np.sin(x1)

I_riemannL1=h1*sum(f1[:n1-1])
err_riemannL1=2-I_riemannL1

I_riemannR1=h1*sum(f1[1::])
err_riemannR1=2-I_riemannR1

I_mid1=h1*sum(np.sin((x1[:n1-1]+x1[1:])/2))
err_mid1=2-I_mid1

print(I_riemannL1)
print(err_riemannL1)

print(I_riemannR1)
print(err_riemannR1)

print(I_mid1)
print(err_mid1)

"""Ch 21.3: Trapezoid Rule"""

import numpy as np

a2=0
b2=np.pi
n1=11
h1=(b1-a1)/(n1-1)
x1=np.linspace(a1,b1,n1)
f1=np.sin(x1)

I_trap2=(h1/2)*(f1[0]+2*sum(f1[1:n1-1])+f1[n1-1])
err_trap2=2-I_trap2

print(I_trap2)
print(err_trap2)

"""Ch 21 End of Chapter Questions

1.
"""

import numpy as np

def my_int_calc(f3,f03,a3,b3,N3,option3):
  h3=(b3-a3)/(N3-1)
  x3=np.linspace(a3,b3,N3)
  F3=f3(x3)
  def riemannIntegral(F3,h3):
    return h3*sum(F3[1::])
  def trapezoidRule(F3,h3):
    return (h3/2)*(F3[0]+2*sum(F3[1:N3-1])+F3[N3-1])
  def simpsonMethod(F3,h3):
    if (len(F3)%2==0):
      raise BasesException("Error: Simpson Method can work only with odd number of data points!")
      return
    return (h3/3)*(F3[0]+2*sum(F3[:N3-2:2])+4*sum(F3[1:N3-1:2])+F3[N3-1])
  I3=0
  if (option3=="trap"):
    I3=trapezoidRule(F3,h3)
  if (option3=="rect"):
    I3=riemannIntegral(F3,h3);
  elif (option3=="simp"):
    I3=simpsonMethod(F3,h3);
  else:
    print("Invalid option")
    return;
  I3=I3+f03
  return I3

def f3(x3):
  return np.sin(x3)

I3=my_int_calc(f3,0,0,3,99,"rect")
print("Riemann",I3)
I3=my_int_calc(f3,0,0,3,99,"trap")
print("Trapezoidal",I3)
I3=my_int_calc(f3,0,0,3,99,"simp")
print("Simpson",I3)

"""    2."""

import numpy as np

def my_poly_int(x4,y4):
  N4=len(x4)*100
  X4=np.linspace(x4[0],x4[-1],N4)
  def LagrangeBasisPolynomials(x4,X4):
    L4=np.ones((len(x4),len(X4)))
    for i in range(0,len(x4)):
      for j in range(0,len(x4)):
        if j==i:
          continue
        else:
          A4=np.array(X4-x4[j])/np.array(x4[i]-X4[j]);
          L4[i,:]=L4[i,:]*A4
    return L4
  def myLagrange(x4,y4,X4):
    Y4=np.zeros(len(X4))
    for i in range(0,len(y4)):
      L4=LagrangeBasisPolynomials(x4,X4);
      Y4=Y4+np.array(y4[i])*np.array(L4[i,:])
    return Y4
  Y4=myLagrange(x4,y4,X4)
  h4=(X4[-1]-X4[0])/(N4-1)
  def simpsonMethod4(F4,h4):
    if (len(F4)%2==1):
      raise BasesException("Error: Simpson method can work only with odd number of data points")
      return
    return (h4/3)*(F4[0]+2*np.sum(F4[np.arange(0,len(F4)-3,2)])+4*np.sum(F4[np.arange(1,len(F4)-2,2)]+F4[-1])
  return simpsonMethod4(Y4,h4)

I4=my_poly_int([1,2,3,4,6,8,10],[4,5,6,10,14,18,22])
print(I4)

"""Reimann Sum Example"""

import numpy as np
import matplotlib.pyplot as plt

f5 = lambda x5 : 1/(1+x5**2)
a5 = 0; b5 = 5; N5 = 10
n5 = 10 # Use n*N+1 points to plot the function smoothly

x5 = np.linspace(a5,b5,N5+1)
y5 = f5(x5)

X5 = np.linspace(a5,b5,n5*N5+1)
Y5 = f5(X5)

plt.figure(figsize=(15,5))

plt.subplot(1,3,1)
plt.plot(X5,Y5,'b')
x_left5 = x5[:-1] # Left endpoints
y_left5 = y5[:-1]
plt.plot(x_left5,y_left5,'b.',markersize=10)
plt.bar(x_left5,y_left5,width=(b5-a5)/N5,alpha=0.2,align='edge',edgecolor='b')
plt.title('Left Riemann Sum, N5 = {}'.format(N5))

plt.subplot(1,3,2)
plt.plot(X5,Y5,'b')
x_mid5 = (x5[:-1] + x5[1:])/2 # Midpoints
y_mid5 = f5(x_mid5)
plt.plot(x_mid5,y_mid5,'b.',markersize=10)
plt.bar(x_mid5,y_mid5,width=(b5-a5)/N5,alpha=0.2,edgecolor='b')
plt.title('Midpoint Riemann Sum, N5 = {}'.format(N5))

plt.subplot(1,3,3)
plt.plot(X5,Y5,'b')
x_right5 = x5[1:] # Left endpoints
y_right5 = y5[1:]
plt.plot(x_right5,y_right5,'b.',markersize=10)
plt.bar(x_right5,y_right5,width=-(b5-a5)/N5,alpha=0.2,align='edge',edgecolor='b')
plt.title('Right Riemann Sum, N = {}'.format(N5))

plt.show()

dx5 = (b5-a5)/N5
x_left5 = np.linspace(a5,b5-dx5,N5)
x_midpoint5 = np.linspace(dx5/2,b5 - dx5/2,N5)
x_right5 = np.linspace(dx5,b5,N5)

print("Partition with",N5,"subintervals.")
left_riemann_sum5 = np.sum(f5(x_left5) * dx5)
print("Left Riemann Sum:",left_riemann_sum5)

midpoint_riemann_sum5 = np.sum(f5(x_midpoint5) * dx5)
print("Midpoint Riemann Sum:",midpoint_riemann_sum5)

right_riemann_sum5 = np.sum(f5(x_right5) * dx5)
print("Right Riemann Sum:",right_riemann_sum5)

I=np.arctan(5)
print(I)

print("Left Riemann Sum Error:",np.abs(left_riemann_sum5 - I))
print("Midpoint Riemann Sum:",np.abs(midpoint_riemann_sum5 - I))
print("Right Riemann Sum:",np.abs(right_riemann_sum5 - I))

"""Trapezoid Rule Example"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

x6 = np.linspace(-0.5,1.5,100)
y6 = np.exp(-x6**2)
plt.plot(x6,y6)

x06 = 0; x16 = 1;
y06 = np.exp(-x06**2); y16 = np.exp(-x16**2);
plt.fill_between([x06,x16],[y06,y16])

plt.xlim([-0.5,1.5]); plt.ylim([0,1.5]);
plt.show()

A6 = 0.5*(y16 + y06)*(x16 - x06)
print("Trapezoid area:", A6)

f6 = lambda x6 : 1/(1 + x6**2)
a6 = 0; b6 = 5; N6 = 10

# x and y values for the trapezoid rule
x6 = np.linspace(a6,b6,N6+1)
y6 = f6(x6)

# X and Y values for plotting y=f(x)
X6 = np.linspace(a6,b6,100)
Y6 = f6(X6)
plt.plot(X6,Y6)

for i in range(N6):
    xs6 = [x6[i],x6[i],x6[i+1],x6[i+1]]
    ys6 = [0,f6(x6[i]),f6(x6[i+1]),0]
    plt.fill(xs6,ys6,'b',edgecolor='b',alpha=0.2)

plt.title('Trapezoid Rule, N6 = {}'.format(N6))
plt.show()