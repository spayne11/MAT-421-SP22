# -*- coding: utf-8 -*-
"""mat421.moduleGhwpt2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eDwfTQ3UvYF-CpN20Mtl7ft5u_NGX-Oi

Sydney Payne

Spring 2022 - MAT 421

Module G Homework: Ch 21.4 and 21.5

Ch 21.4: Simpson's Rule
"""

import numpy as np

a1=0
b1=np.pi
n1=11
h1=(b1-a1)/(n1-1)
x1=np.linspace(a1,b1,n1)
f1=np.sin(x1)

I_simp1=(h1/3)*(f1[0]+2*sum(f1[:n1-2:2])+4*sum(f1[1:n1-1:2])+f1[n1-1])
err_simp1=2-I_simp1

print(I_simp1)
print(err_simp1)

"""Ch 21.5: Computing Integrals in Python"""

import numpy as np
from scipy.integrate import trapz

a2=0
b2=np.pi
n2=11
h2=(b2-a2)/(n2-1)
x2=np.linspace(a2,b2,n2)
f2=np.sin(x2)

I_trapz2=trapz(f2,x2)
I_trap2=(h2/2)*(f2[0]+2*sum(f2[1:n2-1])+f2[n2-1])

print(I_trapz2)
print(I_trap2)

# Commented out IPython magic to ensure Python compatibility.
from scipy.integrate import cumtrapz
import matplotlib.pyplot as plt
# %matplotlib inline
plt.style.use("seaborn-poster")

x3=np.arange(0,np.pi,0.01)
F_exact3=-np.cos(x3)
F_approx3=cumtrapz(np.sin(x3),x3)

plt.figure(figsize=(10,6))
plt.plot(x3,F_exact3)
plt.plot(x3[1::],F_approx3)
plt.grid()
plt.tight_layout()
plt.title("$F(x3)=\int_0^{x3} sin(y3) dy$")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend(["Exact with Offset","Approx"])
plt.show()

from scipy.integrate import quad

I_quad5,est_err_quad5=quad(np.sin,0,np.pi)
print(I_quad5)

err_quad5=2-I_quad5
print(est_err_quad5,err_quad5)

"""End of Chapter Examples

5.
"""

from scipy.integrate import quad
import numpy as np
import matplotlib.pyplot as plt

def my_fourier_coef(f4,N4):
  def F14(x4):
    return np.cos(N4*x4)*f4(x4)
  def F24(x4):
    return np.sin(N4*x4)*f4(x4)
  A_n4=quad(F14,-np.pi,np.pi)[0]
  B_n4=quad(F24,-np.pi,np.pi)[0]
  return[A_n4/np.pi,B_n4/np.pi]

def plot_results(f4,N4):
  x4=np.linspace(-np.pi,np.pi,10000)
  [A04,B04]=my_fourier_coef(f4,0)
  y4=A04*np.ones(len(x4))/2
  for n in range(1,N4):
    [An4,Bn4]=my_fourier_coef(f4,N4)
    y4+=An4*np.cos(N4*x4)+Bn4*np.sin(N4*x4)
  plt.figure(figsize=(10,6))
  plt.plot(x4,f4(x4),label="analytic")
  plt.plot(x4,y4,label="approximate")
  plt.xlabel("x")
  plt.ylabel("y")
  plt.grid()
  plt.legend()
  plt.title("{N4}th Order Fourier Approximation")
  plt.show()

f41=lambda x4: np.sin(np.exp(x4))
N41=2
plot_results(f41,N41)

N42=20
plot_results(f41,N42)

f42= lambda x4: np.mod(x4,np.pi/2)
N43=5
plot_results(f42,N43)

N44=20
plot_results(f42,N44)

f43= lambda x4: (x4>-np.pi/2)&(x4<np.pi/2)
N45=2
plot_results(f43,N45)

N46=20
plot_results(f43,N46)

import scipy.integrate as integrate
import scipy.special as special
result = integrate.quad(lambda x: special.jv(2.5,x), 0, 4.5)
result

from numpy import sqrt, sin, cos, pi
I = sqrt(2/pi)*(18.0/27*sqrt(2)*cos(4.5) - 4.0/27*sqrt(2)*sin(4.5) +
                sqrt(2*pi) * special.fresnel(3/sqrt(pi))[0])
I

print(abs(result[0]-I))

