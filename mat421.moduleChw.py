# -*- coding: utf-8 -*-
"""mat421.moduleChw.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GB0X8i03YqQtagkheeOShIn79vSIvWQy

Sydney Payne

Spring 2022 - MAT 421

Module C Homework: 19.1,19.2,19.3,19.4,19.5

19.1:Root Finding Problem Statement

 Examples from Text
"""

import numpy as np
from scipy import optimize

f1=lambda x1:np.cos(x1)-x1
r1=optimize.fsolve(f1,-2)
print("r=",r1)

#Verify the solution is a root
result=f1(r1)
print("result=",result)

f2=lambda x2:1/x2
r2,infodict,ier,mesg=optimize.fsolve(f2,-2,full_output=True)
print("r=",r2)

result=f2(r2)
print("result=",result)

print(mesg)

"""19.2: Tolerance

19.3:Bisection Method

Examples from Text
"""

import numpy as np

def my_bisection(f3,a3,b3,tol3):
  #approxiamtes a root, R, of f bounded
  # by a and b to within tolerance
  #|f(m)| < tol with m being midpoint
  #between a and b, recursive implementation

  #check if a and b bound a root
  if np.sign(f3(a3))==np.sign(f3(b3)):
    raise Exception("The scalars a and b do not bound a root")

  #get midpoint
  m3=(a3+b3)/2

  if np.abs(f3(m3))<tol3:
    #stopping condition, report m as root
    return m3 
  elif np.sign(f3(a3))==np.sign(f3(m3)):
    #case where m is an improvement on a
    #make recursive call with a=m
    return my_bisection(f3,m3,b3,tol3)
  elif np.sign(f3(b3))==np.sign(f3(m3)):
    #case where m is an improvement on b
    #make recursive call with b=m
    return my_bisection(f3,a3,m3,tol3)

f4=lambda x4:x4**2-2

r14=my_bisection(f4,0,2,0.1)
print("r14=",r14)
r014=my_bisection(f4,0,2,0.01)
print("r014=",r014)

print("f4(r14)=",f4(r14))
print("f4(r014)=",f4(r014))

my_bisection(f4,2,4,0.01)

"""19.4: Newton-Raphson Method

Examples from Text


"""

import numpy as np

f5=lambda x5:x5**2-2
f_prime5=lambda x5:2*x5
newton_raphson5=1.4-(f5(1.4))/(f_prime5(1.4))

print("newton_raphson5=",newton_raphson5)
print("sqrt(2)=",np.sqrt(2))

def my_newton(f5,df5,x05,tol5):
  #output is an estimation of the root of f
  #using the Newton-Raphson method
  #recursive implementation
  if abs(f5(x05))<tol5:
    return x05
  else:
    return my_newton(f5,df5,x05-f5(x05)/df5(x05),tol5)

estimate5=my_newton(f5,f_prime5,1.5,1e-6)
print("estimate5=",estimate5)
print("sqrt(2)=",np.sqrt(2))

x06=0.29
x16=x06-(x06**3+3*x06**2-2*x06-5)/(3*x06**2+6*x06-2)
print("x16=",x16)

"""19.5: Root Finding in Python

Examples from Text
"""

from scipy.optimize import fsolve

f7=lambda x7:x7**3-100*x7**2-x7+100
fsolve(f7,[2,80])

"""19.6: End of Chapter Questions

1.
"""

import numpy as np

def my_nth_root(x191,n191,tol191):

  f191=lambda y191:y191**n191-x191
  f_prime191=lambda y191:n191*(y191**(n191-1))
  r191=1
  r191=my_newton(f191,f_prime191,tol191)
  return r191

x191=64
n191=3
tol191=1e-9

r191=my_nth_root(x191,n191,tol191)
print("r=",r191)

"""2."""

def my_fixed_points(f192,g192,tol192,max_iter192):
  F192=lambda x192: f192(x192)-g192(x192)

  def guess(f192,intitial192):
    istart192=initial192-1
    iend192=initial192+1
    limit192=10000000
    i192=1
    while i192<limit192:
      if (f192(istart192)<0)&(f192(iend192)>0):
        a192=istart192;
        b192=iend192;
        return [a192,b192]
      elif f192(istart192)>0:
        istart192=istart192-1*istart192
      else:
        iend192=iend192+2*iend192
      i192+=1
  [a192,b192]=guess(F192,0)
  i192=1

  def sign(a192):
    return (a192>0)-(a192<0)

  while (i192,max_iter192):
    m192=(a192+b192)/2
    if (abs(F192(m192))<tol192):
      return m192
    elif (sign(F192(m192))==sign(F192(a192))):
      a192=m192
    else:
      b192=m192
  return []

f192=lambda x192:x192**3;
g192=lambda x192:8;
tol192=1e-3;
limit192=10000;
ans=my_fixed_points(f192,g192,tol192,limit192)
print(ans)

"""3. The function f(x)=1/x does not have a root as it does not cross the x-axis. Since this function is not continous or defined at x=0, we cannot use the bisection method."""

import matplotlib.pyplot as plt
import numpy as np

x193=np.linspace(-5,5,100)
f193=1/x193

plt.figure(figsize=(10,8))
plt.plot(f193)
plt.xlabel("x")
plt.ylabel("y")
plt.show()

"""4."""

import numpy as np

def my_bisection(f194,a194,b194,tol194):
  n194=np.ceil(np.log2((b194-a194)/tol194))
  R194=np.zeros(int(n194))
  E194=np.zeros(int(n194))
  limit194=n194;
  i194=0
  def sign(a194):
    if (a194==0):
      return a194
    return a194/abs(a194)
  while (i194<limit194):
    R194[i194]=(a194+b194)/2
    E194[i194]=abs(f194(R194[i194]))
    if (E194[i194]<tol194):
      R194[np.isnan(R194)]=[]
      E194[np.isnan(R194)]=[]
    elif (sign(f194(R194[i194]))==sign(f194(a194))):
      a194=R194[i194]
    else:
      b194=R194[i194]
    i194+=1
  return [R194,E194]

f194=lambda x194:x194**2-2;
a194=0;
b194=2;
tol194=1e-1;
[R194,E194]=my_bisection(f194,a194,b194,tol194)
print([R194,E194])

f1942=lambda x1942:np.sin(x1942)-np.cos(x1942);
tol1942=1e-2
[R194,E194]=my_bisection(f1942,a194,b194,tol1942)
print([R194,E194])

"""5."""

import numpy as np

def my_newton(f195,df195,x0195,tol195):
  R195=[]
  E195=[]
  R195.append(x0195)
  E195.append(abs(f195(R195[-1])))
  limit195=1000
  i195=0
  while i195<limit195:
    R195.append(x0195-(f195(x0195)/df195(x0195)))
    E195.append(abs(f195(R195[-1])))
    if E195[-1]<tol195:
      return [R195,E195]
    x0195=R195[-1]
    i195=i195+1
  return [R195,E195]

f195=lambda x195:x195**2-2
df195=lambda x195:2*x195
[R195,E195]=my_newton(f195,df195,1,1e-5)
print([R195,E195])

f1952=lambda x1952:np.sin(x1952)-np.cos(x1952)
df1952=lambda x1952:np.cos(x1952)+np.sin(x1952)
[R1952,E1952]=my_newton(f1952,df1952,1,1e-5)
print([R1952,E1952])

"""6."""

import numpy as np
import math

def my_pipe_builder(C_ocean,C_land,L,H):
  p1=lambda x196:math.sqrt(H**2+x196**2)
  p2=lambda x196:L-x196
  cost=lambda x196:p1(x196)*C_ocean+p2(x196)*C_land
  error196=lambda a196,b196:cost(a196)-cost(b196)
  tol196=1e-6;
  limit196=int(np.ceil(np.log2(L/tol196)))
  i196=1;
  a196=0;
  b196=L;
  while i196<limit196:
    m196=(a196+b196)/2
    if abs(error196(a196,b196))<tol196:
      return m196
    elif error196(a196,b196)<0:
      b196=m196
    else:
      a196=m196
    i196+=1

my_pipe_builder(20,10,100,50)

my_pipe_builder(30,10,100,50)

my_pipe_builder(30,10,100,20)

"""7."""

import numpy as np

def my_newton2(f197,df197,x0197,tol197):
  R197=[]
  E197=[]
  R197.append(x0197)
  E197.append(abs(f197(R197[-1])))
  limit197=1000
  i197=0
  while i197<limit197:
    R197.append(x0197-(f197(x0197)/df197(x0197)))
    E197.append(abs(f197(R197[-1])))
    if E197[-1]<tol197:
      return [R197,E197]
    x017=R197[-1]
    i197=i197+1
  return [R197,E197]

f197=lambda x197:x197**0.5
df197=lambda x197: 1.0/(2.0*(x197**0.5))
x0197=0
tol197=1e-2
[R197,E197]=my_newton2(f197,df197,0,1e-2)
print(np.real(R197))