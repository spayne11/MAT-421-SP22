# -*- coding: utf-8 -*-
"""mat421.moduleBhw.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rdb1enmoaQYMczIy36L71oPyImRsaddj

Sydney Payne

Spring 2022 - MAT 421

Module B Homework

17.2 Examples from Text
"""

from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

plt.style.use("seaborn-poster")

x=[0,1,2]
y=[1,3,2]

f=interp1d(x,y)
y_hat=f(1.5)
print(y_hat)

plt.figure(figsize=(10,8))
plt.plot(x,y,"-ob")
plt.plot(1.5,y_hat,"ro")
plt.title("Linear Interpolation at x=1.5")
plt.xlabel("x")
plt.ylabel("y")
plt.show()

"""17.3 Examples from Text"""

from scipy.interpolate import CubicSpline
import numpy as np
import matplotlib.pyplot as plt

plt.style.use("seaborn-poster")

x2=[0,1,2]
y2=[1,3,2]

#use bc_type="natural" adds the constraints
f2=CubicSpline(x2,y2,bc_type="natural")
x_new=np.linspace(0,2,100)
y_new=f2(x_new)

plt.figure(figsize=(10,8))
plt.plot(x_new,y_new,"b")
plt.plot(x2,y2,"ro")
plt.title("Cubic Spline Interpolation")
plt.xlabel("x")
plt.ylabel("y")
plt.show()

b=np.array([1,3,3,2,0,0,0,0])
b=b[:,np.newaxis]
A=np.array([[0,0,0,1,0,0,0,0],[0,0,0,0,1,1,1,1],[1,1,1,1,0,0,0,0],[0,0,0,0,8,4,2,1],[3,2,1,0,-3,-2,-1,0],[6,2,0,0,-6,-2,0,0],[0,2,0,0,0,0,0,0],[0,0,0,0,12,2,0,0]])

np.dot(np.linalg.inv(A),b)

"""17.4 Examples from Text"""



import numpy as np
import numpy.polynomial.polynomial as poly
import matplotlib.pyplot as plt

plt.style.use("seaborn-poster")

x3=[0,1,2]
y3=[1,3,2]
p1_coeff=[1,-1.5,.5]
p2_coeff=[0,2,-1]
p3_coeff=[0,-.5,.5]

#get the polynomial function
p1=poly.Polynomial(p1_coeff)
p2=poly.Polynomial(p2_coeff)
p3=poly.Polynomial(p3_coeff)

x3_new=np.arange(-1.0,3.1,0.1)

fig=plt.figure(figsize=(10,8))
plt.plot(x3_new,p1(x3_new),"b",label="P1")
plt.plot(x3_new,p2(x3_new),"b",label="P2")
plt.plot(x3_new,p3(x3_new),"b",label="P3")

plt.plot(x3,np.ones(len(x3)),"ko",x3,np.zeros(len(x3)),"ko")
plt.title("Lagrange Basis Plynomials")
plt.xlabel("x")
plt.ylabel("y")
plt.grid()
plt.legend()
plt.show()

L=p1+3*p2+2*p3

fig=plt.figure(figsize=(10,8))
plt.plot(x3_new,L(x3_new),"b",x3,y3,"ro")
plt.title("Lagrange Polynomial")
plt.grid()
plt.xlabel("x")
plt.ylabel("y")
plt.show()

from scipy.interpolate import lagrange

f4=lagrange(x3,y3)

fig=plt.figure(figsize=(10,8))
plt.plot(x3_new,f4(x3_new),"b",x3,y3,"ro")
plt.title("Lagrange Polynomial")
plt.grid()
plt.xlabel("x")
plt.ylabel("y")
plt.show()

"""17.5 Examples from Text"""

clear[x,y,x4_data,y4_data,x_data,y_data,x4,y4,a_s,newton_poly,divided_diff]

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt

plt.style.use('seaborn-poster')

# %matplotlib inline

def divided_diff(x, y):
    '''
    function to calculate the divided
    differences table
    '''
    n = len(y)
    coef = np.zeros([n, n])
    # the first column is y
    coef[:,0] = y
    
    for j in range(1,n):
        for i in range(n-j):
            coef[i][j] = \
           (coef[i+1][j-1] - coef[i][j-1]) / (x[i+j]-x[i])
            
    return coef

def newton_poly(coef, x_data, x):
    '''
    evaluate the newton polynomial 
    at x
    '''
    n = len(x_data) - 1 
    p = coef[n]
    for k in range(1,n+1):
        p = coef[n-k] + (x -x_data[n-k])*p
    return p

x = np.array([-5, -1, 0, 2])
y = np.array([-2, 6, 1, 3])
# get the divided difference coef
a_s = divided_diff(x, y)[0, :]

# evaluate on new data points
x_new = np.arange(-5, 2.1, .1)
y_new = newton_poly(a_s, x, x_new)

plt.figure(figsize = (12, 8))
plt.plot(x, y, 'bo')
plt.plot(x_new, y_new)

"""Ch 17 Problems

1.
"""

def my_lin_interp(a_list,b_list,a_val):
  print("interpolation formula:b(A)=b1+[(b2-b1)/(a2-a1)](A-a1) where a1-->ai and b1-->bi and a2-->ai+1 and b2-->bi+1")
  #a=[1,2.5,3.4,5.8,6]
  a=a_list
  b1=b_list
  b=a_val
  j=0
  listlen=len(a)
  print(listlen)
  print(a[0:1])
  print(a[1:2])
  #temp=(a[0:2:1])
  #print(temp)
  for m in range(listlen):
    if j+1==listlen:
      break
    if a[j]<b and b<a[j+1]:
      print("number in range of {} and {} i.e between index {} and {}".format(a[j],a[j+1],j,j+1))
      print("these are a1 and a2 values similarly pick up corresponding b1 and b2 values from list b")
      print(b1[j])
      print(b1[j+1])
      intervals=zip(a_list,a_list[1:],b_list,b_list[1:])
      for v in intervals:print(v)
      return a[j],a[j+1],b1[j],b1[j+1]
    else:
      print("number not in range of {} and {}".format(a[j],a[j+1]))
      #return 0
    j+=1
  #interp=my_lin_interp(a_list,be_list,4)
  a_list,b_list=[1,2.5,3.4,5.8,6],[2,4,5.8,4.3,4]
  a_val=3
  a1,a2,b1,b2=my_lin_interp(a_list,b_list,a_val)
  print(a1,a2,b1,b2)
  slope1=b2-b1/a2-a1
  print(slope1)
  b_a_val=b1+slope*(a_val-a1)
  print("therefore the interpolation at a=3 is:",b_a_val)

my_lin_interp((1,2.5,2,4),(2.5,3.4,4,5.8),3)

"""2."""

import numpy as np

def my_cubic_spline(c_list,d_list,c_val):
  c=c_list
  d1=d_list
  d=c_val
  j=0
  listlen2=len(c)
  print(listlen2)
  print(c[0:1])
  print(c[1:2])
  ans2=np.array([1,2,0,0,0])
  #print(ans2)
  and2=ans2[:,np.newaxis]
  print(ans2)
  cubic=np.array([[1,1,0,0,0],[0,0,1,1,1],[1,3,-1,0,0],[0,3,0,-1,0],[0,0,0,2,6]])
  array2=np.dot(np.linalg.inv(cubic),ans2)
  print(array2)
  print("a0=0,a1=3,c0=0,b0={},d0={},b1={},c1={},d1={}".format(array2[0],array2[1],array2[2],array2[3],array2[4]))
  #s0=a0+b0(x-1)+c0(x-1)**2+d0(x-1)**3
  s0=2+array2[2]*(1.5-1)+array2[3]*(1.5-1)**2+array2[4]*(1.5-1)**3
  print("x=1.5 lines between [1,2] and [2,3] therfore calculating s0",s0)
  #print(s1)
  return ans2,s0
  c_list,d_list=[1,2,3],[2,3,5]
  c_val=1.5
  sol,s0=my_cubic_spline(c_list,d_list,c_val)
  print("therefore the cubic natural spline interpolation at x=1.5 is:",s0)

my_cubic_spline((1,2,3),(2,3,5),1.5)

"""3."""

e_list=np.array([2.14,3.25,4.36,5.47,6.58])
f_list=np.array([3.65,5.86,7.47,5.99,6.8])

import numpy as np
import matplotlib.pyplot as plt

e_list=np.array([2.14,3.25,4.36,5.47,6.58])
f_list=np.array([3.65,5.86,7.47,5.99,6.8])
def my_nearest_neigbor(e0,f0,e_val):
  ei=np.abs(e_list-e0).argmin()
  #argmin returns indices of the min element of the array in a particular axis
  print("e_list-e0=",(e_list-e0))
  print("e_list:",e_list,"\nei:",ei)
  fi=np.abs(f_list-f0).argmin()
  print("f_list-f0=",(f_list-f0))
  print("f_list:",f_list,"\nfi:",fi)
  e_list=np.array([2.14,3.25,4.36,5.47,6.58])
  f_list=np.array([3.65,5.86,7.47,5.99,6.8])
  data3=np.array([[1,0,1,0,1],[0,1,1,1,0],[1,1,0,0,0],[0,1,1,1,0],[1,1,1,0,0]])
  print(data3)
  dat31=my_nearest_neighbor(4.1,5.9,e_list)
  print("data at (4.1,5.9)=:",dat31)
  dat32=my_nearest_neighbor(6.7,4.1,e_list)
  print("data at (6.7,4.1)=:",dat32)
  plt.plot(e_list,f_list,"ro")
  plt.plot(e_list,f_list,"b")
  plt.annotate("Point1",(4.1,5.9),size=20)
  plt.plot(4.1,5.9,'ro',ms=15)
  plt.annotate("Point2",(6.7,4.1),size=20)
  plt.plot(6.7,4.1,'ro',ms=15)
  plt.xlabel("e",size=20)
  plt.ylabel("f",size=20)
  plt.title("Nearest Neighbor Interpolation",size=20)
  plt.show()

my_nearest_neigbor((2.14,3.25,4.36,5.47,6.58),(3.65,5.86,7.47,5.99,6.8),1)

"""4. When the degree of the ploynomial is 1, the cubic spline almost resembles a linear regression.

5.
"""

print("clamped spline")
import numpy as np
def my_cubic_spline_flat(g_list,h_list,g_val):
  g=g_list
  h1=h_list
  h=g_val
  j=0
  listlen5=len(g)
  print(listlen5)
  print(g[0:1])
  print(g[1:2])
  ans5=np.array([1,2,0,0,0])
  #print(ans5)
  ans5=ans5[:,np.newaxis]
  print(ans5)
  cubic5=np.array([[1,1,0,0,0],[0,0,1,1,1],[2,3,-1,0,0],[1,3,0,-1,0],[0,0,1,2,3]])
  array5=np.dot(np.linalg.inv(cubic5),ans5)
  print(array5)
  print("a0=0,a1=3,b0=0,c0={},d0={},b1={},c1={},d1={}".format(array5[0],array5[1],array5[2],array5[3],array5[4]))
  s50=2+0+array5[0]*(1.5-1)**2+array5[1]*(1.5-1)**3
  #[x=2,y=3]s1=a1+b1(x-1)+c1(x-1)**2+d1(x-1)**3
  s51=3+array5[2]*(1.5-1)+array5[3]*(1.5-1)**2+array5[4]*(1.5-1)**3
  print("g=1.5 lies between [1,2] and [2,3] therefore calculating s50",s50)
  #print(s51)
  return ans5,s50
  g_list,h_list=[1,2,3],[2,3,5]
  g_val=1.5
  sol,s50=my_cubic_spline_flat(g_list,h_list,g_val)
  print("therefore the cubic clamped spline interpolation at g=1.5 is:",s50)

my_cubic_spline_flat((1,2,3),(2,3,5),1.5)

"""6."""

import numpy as np
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

def my_quintic_spline(m_list,n_list,m_val):
  D=4
  plt.style.use("seaborn-poster")
  f6=CubicSpline(m_list,n_list,m_val)
  
  plt.figure(figsize=(10,6))
  n_new=f6(m_list)
  plt.plot(m_val,n_new,"n",label="clamped")
  plt.scattered(m_list,n_list)
  plt.title("Quintic Spline Clamped Interpolation")
  plt.xlabel("m")
  plt.ylabel("n")
  plt.annotated("Point (m={},n={})".format(1.5,f6(1.5)),(1.5,f6(1.5)),size=15)
  plt.plot(1.5,f6(1.5),'ro',ms=25)
  return n_new
  m_list,n_list=[1,2,3,4,5,6,7,8,9],[2,3,5,6,7,9,10,11,12]
  m_val=np.linspace(0,9,100)
  n_new=my_quintic_spline(m_list,n_list,m_val)
  plt.show()

my_quintic_spline([1,2,3,4,5,6,7,8,9],[2,3,5,6,7,9,10,11,12],1.5)

"""7."""

import matplotlib.pyplot as plt
import numpy as np
from scipy import interpolate

def my_interp_plotter(o,p,o_val,kind):
  plt.figure(figsize=(10,8))
  plt.plot(o,p,'ro',label="data")
  f7=interpolate.interp1d(o,p,kind)
  P=f7(o_val)
  plt.plot(o_val,P,"b",label=kind)
  plt.xlabel("X")
  plt.ylabel("Y")
  plt.legend()
  if kind=="nearest":
    plt.title("nearest interpolation of data")
  elif kind=="linear":
    plt.title("linear interpolation of data")
  else: 
    plt.title("cubic interpolation of data")
    plt.show()

  x7=np.array([0,0.1,0.15,0.35,0.6,0.7,0.95,1])
  y7=np.array([1,0.8187,0.7408,0.4966,0.3012,0.2466,0.1496,0.1353])

x7=np.array([0,0.1,0.15,0.35,0.6,0.7,0.95,1])
y7=np.array([1,0.8187,0.7408,0.4966,0.3012,0.2466,0.1496,0.1353])

my_interp_plotter(x7,y7,np.linspace(0,1,101),"nearest")

my_interp_plotter(x7,y7,np.linspace(0,1,101),"linear")

my_interp_plotter(x7,y7,np.linspace(0,1,101),"cubic")

"""8."""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline
print("Clamped Spline")

def my_D_cubic_spline(x8,y8,x8_val,D):
  plt.style.use("seaborn-poster")
  f8=CubicSpline(x8,y8,bc_type=((1,D),(1,D)))
  y8_new=f8(x8)
  plt.plot(x8_val,y8_new,"b",label="clamped")
  plt.scattered(x8,y8)
  plt.plot(1.5,f8(1.5),'ro',ms=25)
  return y8_new

  x8,y8=[0,1,2,3,4],[0,0,1,0,0]
  x8_val=np.linspace(0,4,101)
  y8_val=my_D_cubic_spline(x8,y8,1.5,1)
  
  plt.figure(figsize=(10,8))
  plt.subplot(221)
  plt.plot(x8,y8,"ro",x8_val,my_D_cubic_spline(x8,y8,x8_val,0),"b")
  plt.subpot(222)
  plt.plot(x8,y8,"ro",x8_val,my_D_cubic_spline(x8,y8,x8_val,1),"b")
  plt.subplot(223)
  plt.plot(x8,y8,"ro",x8_val,my_D_cubic_spline(x8,y8,x8_val,-1),"b")
  plt.subplot(224)
  plt.plot(x8,y8,"ro",x8_val,my_D_cubic_spline(x8,y8,x8_val,4),"b")
  plt.tight_layout()
  plt.show()
  print("therefore the cubic clamped spline interpolation at x=1.5 is:",y8_val)

x8=[0,1,2,3,4]
y8=[0,0,1,0,0]
x8_val=np.linspace(0,4,101)

my_D_cubic_spline(x8,y8,1.5,1)

"""9."""

import numpy as np
import matplotlib.pyplot as plt

def my_lagrange(x9,y9,x9_val):
  y9_val=0
  for i in range(len(x9)):
    P9=1
  for j in range(len(x9)):
    if i!=j:
      Px9=x9_val-x9[j]
    Dx9=x9[i]-x9[j]
    P9=P9*Px9/Dx9
    y9_val=y9[i]*P9+y9_val
    return y9_val

    x9=[0,1,2,3,4]
    y9=[2,1,3,5,1]
    x9_val=np.linspace(0,4,101)

    plt.figure(figsize=(10,8))
    plt.plot(x9_val,my_lagrange(x9,y9,x9_val),"b",label="interpolation")
    plt.plot(x9,y9,"ro",label="data points")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.title("Lagrange Interpolation of Data Points")
    plt.legend()
    plt.show()

x9=[0,1,2,3,4]
y9=[2,1,3,5,1]
x9_val=np.linspace(0,4,101)

my_lagrange(x9,y9,x9_val)

plt.plot(x9_val,my_lagrange(x9,y9,x9_val),"b",label="interpolation")
plt.plot(x9,y9,"ro",label="data points")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Lagrange Interpolation of Data Points")
plt.legend()
plt.show()

"""10."""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt

plt.style.use('seaborn-poster')

# %matplotlib inline

def divided_diff(x10, y10):
    '''
    function to calculate the divided
    differences table
    '''
    n = len(y10)
    coef = np.zeros([n, n])
    # the first column is y10
    coef[:,0] = y10
    
    for j in range(1,n):
        for i in range(n-j):
            coef[i][j] = \
           (coef[i+1][j-1] - coef[i][j-1]) / (x[i+j]-x[i])
            
    return coef

def newton_poly(coef, x_data10, x10):
    '''
    evaluate the newton polynomial 
    at x10
    '''
    n = len(x_data10) - 1 
    p = coef[n]
    for k in range(1,n+1):
        p = coef[n-k] + (x10 -x_data10[n-k])*p
    return p

x10 = np.array([0,1,2,3,4])
y10 = np.array([2,1,3,5,1])
# get the divided difference coef
a_s10 = divided_diff(x10, y10)[0, :]

# evaluate on new data points
x_new10 = np.arange(-5, 2.1, .1)
y_new10 = newton_poly(a_s10, x10, x_new10)

plt.figure(figsize = (12, 8))
plt.plot(x10, y10, 'bo')
plt.plot(x_new10, y_new10)

