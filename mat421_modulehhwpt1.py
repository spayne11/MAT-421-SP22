# -*- coding: utf-8 -*-
"""mat421.moduleHhwpt1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hUgUrPXrhgvPQPAekQIpVfxlGRCfSbV5

Sydney Payne

Spring 2022 - MAT 421

Module H Homework: 22.1, 22.2, 22.3

Ch 22.3: The Euler Method
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt

plt.style.use('seaborn-poster')
# %matplotlib inline

# Define parameters
f = lambda t, s: np.exp(-t) # ODE
h = 0.1 # Step size
t = np.arange(0, 1 + h, h) # Numerical grid
s0 = -1 # Initial Condition

# Explicit Euler Method
s = np.zeros(len(t))
s[0] = s0

for i in range(0, len(t) - 1):
    s[i + 1] = s[i] + h*f(t[i], s[i])

plt.figure(figsize = (12, 8))
plt.plot(t, s, 'bo--', label='Approximate')
plt.plot(t, -np.exp(-t), 'g', label='Exact')
plt.title('Approximate and Exact Solution \
for Simple ODE')
plt.xlabel('t')
plt.ylabel('f(t)')
plt.grid()
plt.legend(loc='lower right')
plt.show()

h = 0.01 # Step size
t = np.arange(0, 1 + h, h) # Numerical grid
s0 = -1 # Initial Condition

# Explicit Euler Method
s = np.zeros(len(t))
s[0] = s0

for i in range(0, len(t) - 1):
    s[i + 1] = s[i] + h*f(t[i], s[i])

plt.figure(figsize = (12, 8))
plt.plot(t, s, 'b--', label='Approximate')
plt.plot(t, -np.exp(-t), 'g', label='Exact')
plt.title('Approximate and Exact Solution \
for Simple ODE')
plt.xlabel('t')
plt.ylabel('f(t)')
plt.grid()
plt.legend(loc='lower right')
plt.show()

"""End of Chapter Questions

1.
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from functools import partial
plt.style.use('seaborn-poster')

# %matplotlib inline

def my_logistic_eq(t1,P1,r1,K1):
  dP1=r1*P1*(1-P1/K1)
  return dP1
dP1=my_logistic_eq(0,10,1.1,15)
print(dP1)

t01=0
tf1=20
P01=10
r1=1.1
K1=20
t1=np.linspace(0,20,2001)
f1=partial(my_logistic_eq,r1=r1,K1=K1)
sol1=solve_ivp(f1,[t01,tf1],[P01],t_eval1=t1)
plt.figure(figsize=(10,8))
plt.plot(sol1.t1,sol1.y1[0])
plt.plot(t1,K1*P01*np.exp(r1*t1)/(K1+P01*(np.exp(r1*t1)-1)),"r:")
plt.xlabel("time")
plt.ylabel("population")
plt.legend(["Numerical Solution","Exact Solution"])
plt.grid(True)
plt.show()

from functools import partial

t0 = 0
tf = 20
P0 = 10
r = 1.1
K = 20
t = np.linspace(0, 20, 2001)

f = partial(my_logisitcs_eq, r=r, K=K)
sol=solve_ivp(f,[t0,tf],[P0],t_eval=t)

plt.figure(figsize = (10, 8))
plt.plot(sol.t, sol.y[0])
plt.plot(t, \
  K*P0*np.exp(r*t)/(K+P0*(np.exp(r*t)-1)),'r:')
plt.xlabel('time')
plt.ylabel('population')

plt.legend(['Numerical Solution', \
            'Exact Solution'])
plt.grid(True)
plt.show()

"""    2."""

import numpy as np

def my_lorenz(t3,S3,sigma,rho,beta):
  if (sigma<0) or (rho<0) or (rho<0):
    raise BaseException("Error: Sigma, rho and beta needs all to be non-negative!")
  dS3=np.zeros(3)
  dS3[0]=sigma*(S3[2]-S3[1])
  dS3[1]=S3[0]*(rho-S3[2])-S3[1]
  dS3[2]=S3[0]*S3[1]-beta*S3[2];
  return dS3

s3=np.array([1,2,3])
dS3=my_lorenz(0,s3,10,28,8/3)
print(dS3)

import numpy as np

def odeEuler(f2,y02,t2):
  y2 = np.zeros(len(t2))
    y2[02] = y02
    for n in range(0,len(t2)-1):
        y2[n+1] = y2[n] + f2(y2[n],t2[n])*(t2[n+1] - t2[n])
    return y2

import numpy as np

t2 = np.linspace(0,2,21)
y02 = 1
f2 = lambda y2,t2: y2
y2 = odeEuler(f2,y02,t2)
y_true = np.exp(t)
plt.plot(t2,y2,'b.-',t2,y_true,'r-')
plt.legend(['Euler','True'])
plt.axis([0,2,0,9])
plt.grid(True)
plt.title("Solution of $y'=y , y(0)=1$")
plt.show()

import numpy as np
from matplotlib import pyplot as plt
x0 = 0
y0 = 1
xf = 10
n = 101
deltax = (xf−0)/(n−1)
x = np.linspace(x0,xf,n)
y = np.zeros([n])
y[0] = y0
for i in range(1,n):
y[i] =deltax ∗(−y[i−1]+np.sin(x[i−1]))+y[i−1]
for i in range(n):
print(x[i],y[i])
plt.plot(x,y,’o ’)
plt.xlabel(”Value of x”)
plt.ylabel(”Value of y”)
plt.title(”Approximate Solution with Forward Euler ’ s Method”)
plt.show()

